# -*- coding: utf-8 -*-
#---------------------------------------------------------------------------
# This file reads the XML file and generates the Linker file(.icf) files.

"""ABOUT THE KEYWORDS(VariableName):
    storageType is the type of storage such as ROM ,RAM ,NV .
    moduleName is the type of module such as bootloader,system,module1.....module4 etc..
    symbolName is the symbols in the module such as region16_start,region16_end ... etc.
    address is the actual address
"""

import xml.etree.ElementTree as ET


##############################################################This class contains all the constants used in the program#############################
class Constants:
    def __init__(self):
        self.OPENCOMMENT = "/*** "
        self.CLOSECOMMENT = " ***/"
        self.DEFINE = "define"
        self.END = ";"
        self.NEWLINE = "\n"
        self.SYMBOL = "symbol"
        self.EXPORTED= "exported"
        self.SPACE = " "
        self.UNDERSCORE = "_"
        self.EQUALS = " = "
        self.WARNING = "THIS FILE IS AUTOGENERATED:DO NOT EDIT"
        self.EXTENSION = ".icf"
        self.SPECIALADRESSES= "Special Adresses"

##########################################################This class contains all the variables that are used in the file########################

class Variables:
    storageType = ""
    moduleName = ""
    symbolName = ""
    address = ""
    symbolOrExported = ""
    constantObj=Constants()
    addressICF=""

################################################################## Parsing Storage Name###################################################
def parseStorageTypeName(root, variableObj,addressICF):
    variableObj.addressICF = addressICF
    for storageType in root:
        #print(storageType.tag)
        variableObj.storageType=storageType.tag
        createEmptyLinkerFile(storageType,variableObj)                                      #creating new .icf file for each storageType
        appendInLinkerFile(getHeaderWarningString(variableObj),variableObj)
        parseModuleName(storageType, variableObj)

################################################################Parsing Module Name  ########################################################
def parseModuleName(storageType, variableObj):
    for moduleName in storageType:
        if(moduleName.tag != "Meta_Data"):                             # to ignore Meta_Data tag
            #print(moduleName.tag)
            variableObj.moduleName=moduleName.tag
            appendInLinkerFile(getModuleNameCommentString(variableObj),variableObj)
            parseSymbolName(moduleName, variableObj)
            appendInLinkerFile(variableObj.constantObj.NEWLINE,variableObj)

#####################################################################parsing Symbol Name###################################################
def parseSymbolName(moduleName, variableObj):
    for symbolName in moduleName:
        #print(symbolName.tag)
        #print(moduleName.find(symbolName.tag).text)
        variableObj.symbolName=symbolName.tag
        variableObj.address=moduleName.find(symbolName.tag).text             #this line gives the address stored in the symbol
        setSymbolOrExportedVariable(symbolName,variableObj)
        appendInLinkerFile(getModuleLineString(variableObj),variableObj)
        #parseSymbolOrExported(symbolName, variableObj)

def setSymbolOrExportedVariable(symbolName,variableObj):
    if(isExportedInNode(symbolName,variableObj)):
        variableObj.symbolOrExported = variableObj.constantObj.EXPORTED+variableObj.constantObj.SPACE+variableObj.constantObj.SYMBOL
    else:
        variableObj.symbolOrExported =variableObj.constantObj.SYMBOL


###################################################################################################################################################
####################################################Formating the data for the linker file#########################################################
####################################################################################################################################################
#------------------------------------------to check if <exported> tag exists----------------------------------------------------#
def isExportedInNode(symbolName,variableObj):
    if(list(symbolName)):
        if(symbolName.find(variableObj.constantObj.EXPORTED).tag == variableObj.constantObj.EXPORTED):
            return True
    return False


def getHeaderWarningString(variableObj):
    line = variableObj.constantObj.OPENCOMMENT + variableObj.constantObj.WARNING + variableObj.constantObj.CLOSECOMMENT + variableObj.constantObj.NEWLINE
    return line


def getModuleNameCommentString(variableObj):
    if(variableObj.moduleName!= 'Special_Adresses'):
        line = variableObj.constantObj.OPENCOMMENT+variableObj.moduleName+variableObj.constantObj.CLOSECOMMENT+variableObj.constantObj.NEWLINE
    else:
        line = variableObj.constantObj.OPENCOMMENT+variableObj.constantObj.SPECIALADRESSES+variableObj.constantObj.CLOSECOMMENT+variableObj.constantObj.NEWLINE
    return line


def getModuleLineString(variableObj):
    if(variableObj.moduleName!= 'Special_Adresses'):
        line= variableObj.constantObj.DEFINE + variableObj.constantObj.SPACE + variableObj.symbolOrExported + variableObj.constantObj.SPACE + variableObj.constantObj.UNDERSCORE + variableObj.storageType + variableObj.constantObj.UNDERSCORE + variableObj.symbolName + variableObj.constantObj.UNDERSCORE + variableObj.moduleName + variableObj.constantObj.EQUALS + variableObj.address + variableObj.constantObj.END + variableObj.constantObj.NEWLINE
    else:
        line= variableObj.constantObj.DEFINE + variableObj.constantObj.SPACE + variableObj.symbolOrExported + variableObj.constantObj.SPACE + variableObj.constantObj.UNDERSCORE + variableObj.storageType + variableObj.constantObj.UNDERSCORE + variableObj.symbolName + variableObj.constantObj.EQUALS + variableObj.address + variableObj.constantObj.END + variableObj.constantObj.NEWLINE
    return line


#---------------------------To empty the existing linker file and create linker file if it doesn't exists-------------------------#
def createEmptyLinkerFile(storageType,variableObj):
    path = variableObj.addressICF + variableObj.storageType + variableObj.constantObj.EXTENSION
    outfile=open(path,'w')

#--------------------------------------------To append data in linker file------------------------------------------------------#
def appendInLinkerFile(currentLine,variableObj):
    path = variableObj.addressICF + variableObj.storageType + variableObj.constantObj.EXTENSION
    outfile=open(path,'a')
    outfile.write(currentLine)


############################################################ MAIN FUNCTION##########################################################################
def main():
    addressXML ="Data.xml"
    addressICF =""
    infile=open(addressXML,"r")
    root = ET.fromstring(infile.read())
    variableObj = Variables()    #Creating object of Variables Class
    parseStorageTypeName(root,variableObj,addressICF)


if __name__ == "__main__":
    main()

#end of program
